[
	{
		"pathDirectory": "inicio",
		"title": "In√≠cio",
		"pages": [
			{
				"path": "javascript",
				"subtitle": "Javascript",
				"content": "JavaScript √© uma linguagem de programa√ß√£o que foi criada inicialmente para utiliza√ß√£o em websites, mas hoje em dia aparece em diversos outros lugares.\nA linguagem foi criada em 1995, mas foi atualizada ao longo dos anos.\nEm compara√ß√£o com outras linguagens de programa√ß√£o, JavaScript √© uma das mais f√°ceis de aprender, tornando-a uma boa primeira escolha.\nEssa √© uma introdu√ß√£o aos fundamentos da programa√ß√£o utilizando a forma moderna dela."
			},
			{
				"path": "estrutura-basica",
				"subtitle": "Estrutura b√°sica",
				"content": "Para come√ßar, vou introduzir esse peda√ßo de c√≥digo: `console.log(100)`.\nAs palavras `console.log` v√£o aparecer diversas vezes por aqui. Voc√™ usa isso quando quiser mostar algo na tela. Mais especificamente, mostrar num tal de \"console\".\nVoc√™ escolhe o que quer que apare√ßa entre os par√™nteses.\nAqui, essa vai ser a √∫nica fun√ß√£o do console, e ele vai ser representado assim: com o c√≥digo na esquerda e o resultado na direita:\n```console.log(100)```\nN√∫meros n√£o s√£o a √∫nica op√ß√£o para escolher. Podemos usar texto tamb√©m, por exemplo. Use a caixa de texto para escolher uma palavra, ou mais de uma:\n```console.log($TEXT)```\nLembrando que o c√≥digo na esquerda gera o resultado na direita.\nVoc√™ pode ter percebido que eu coloquei aspas no exemplo anterior, as aspas s√£o usadas no come√ßo e fim de peda√ßos de texto.\nAqui o console mostra as aspas tamb√©m, mas em outros lugares pode n√£o mostrar.\nUm valor de texto √© chamado pelo nome ingl√™s **_\"string\"_**. Nos c√≥digos daqui eles v√£o aparecer em laranja.\nS√£o usadas linhas diferentes para cada instru√ß√£o.\n```console.log(\"Sauda√ß√µes\")\nconsole.log(-5)```\n###Coment√°rios\nDuas barras `//` representam o come√ßo de um coment√°rio, que faz o resto da linha ser ignorada completamente na hora da execu√ß√£o.\nComent√°rios v√£o ficar em cinza.\n```// Este √© um coment√°rio, senhor```"
			},
			{
				"path": "variaveis",
				"subtitle": "Vari√°veis",
				"content": "Vari√°veis s√£o o conceito b√°sico mais importante. Elas funcionam como caixas de informa√ß√µes, voc√™ armazena alguma coisa nela e pode retirar o que tem dentro depois.\nPara criar uma vari√°vel voc√™ usa a palavra especial `let` e precisa dar um nome para ela:\n```let nome```\nFazer isso recebe o nome de **\"declarar\"** uma vari√°vel.\n√â importante notar que esse nome n√£o pode conter espa√ßos. Se voc√™ quiser mais de uma palavra no nome, em vez de espa√ßos √© comum juntarAsPalavrasDesseJeito.\n```let nomeMaisLongo```\nPara fazer a vari√°vel √∫til √© preciso dar um valor para ela.\nEsse valor pode ser por exemplo um n√∫mero, uma letra, uma palavra, uma frase, o dicion√°rio todo...\n```let numero = 15\nlet fantasmasAtrasDeVoce = 1\nlet contaBancaria = -10.45\n// Tamb√©m n√£o √© recomendado usar acentos no nome```\nUsa-se um ponto em vez de uma v√≠rgula para n√∫meros quebrados.\nQuando voc√™ quiser colocar uma _string_ numa vari√°vel, novamente, precisa usar aspas.\n```let professor = \"Girafales\"\nlet frase = \"Voc√™ vem sempre aqui?\"```\nO s√≠mbolo de igual aqui pode parecer meio estranho, ele s√≥ representa a a√ß√£o de colocar um valor numa vari√°vel, na esquerda do igual fica o nome dela e na direita o valor.\nDepois de criar uma, pode mudar o valor dela de acordo com a segunda linha de c√≥digo abaixo:\n```let saudacao = \"Bom dia, boa tarde, boa noite.\"\nsaudacao = \"Sauda√ß√µes, terr√°queos! Eu venho em paz.\"```\nComo a fun√ß√£o do `let` √© s√≥ declarar (criar) vari√°veis, n√£o reapareceu na segunda linha.\nNo lugar de `let`, voc√™ tamb√©m pode usar `const`. A diferen√ßa √© que uma vari√°vel criada com `const` n√£o pode ser alterada mais.\n```const sentidoDaVida = 42```\nPara ver o valor da vari√°vel, o `console.log()` de antes voltou.\n```let importante = $NUMBER\nconsole.log(importante)```\nNo lugar do n√∫mero ou palavra de antes voc√™ coloca o nome da vari√°vel. \nN√£o s√≥ nesse caso, mas **em qualquer lugar que voc√™ pode usar um n√∫mero, voc√™ tamb√©m pode usar uma vari√°vel de n√∫mero**.\nO mesmo vale para outros tipos de vari√°vel."
			},
			{
				"path": "operacoes-matematicas",
				"subtitle": "Opera√ß√µes matem√°ticas",
				"content": "Em c√≥digo, existem as opera√ß√µes matem√°ticas b√°sicas.\n```console.log(2 + 2)\nconsole.log(18 - 5)```\nO resultado das opera√ß√µes pode ser colocado numa vari√°vel:\n```let resultado = 6 * 4\nconsole.log(resultado)```\nOu pode ser obtido de uma vari√°vel:\n```let valorInicial = 38\nconsole.log(valorInicial / 2)```\nOu os dois ao mesmo tempo. No geral, qualquer lugar que aceita um n√∫mero tamb√©m aceita uma opera√ß√£o matem√°tica.\n```let numero = 68\nnumero = numero + 1\nconsole.log(numero)```\nEsse `numero = numero + 1` no meio do c√≥digo acima √© uma ideia importante e vai voltar no futuro. Ele aumenta a vari√°vel em 1, o processo √© assim:\n`numero = numero + 1`\n`numero = 68 + 1`\t\t<< valor 68 √© extra√≠do\n`numero = 69`\t\t<< valor 69 √© atribu√≠do\nSimilarmente, `numero = numero * 2` dobraria o valor.\n\nExpress√µes com mais de uma opera√ß√£o tamb√©m s√£o poss√≠veis. Elas usam a mesma ordem do que a matem√°tica: multiplica√ß√£o e divis√£o primeiro, depois soma e subtra√ß√£o.\n```console.log(1 + 3 * 3)```\n```console.log((1 + 3) * 3) // par√™nteses tamb√©m afetam a ordem```\nPor √∫ltimo, o s√≠mbolo de mais tamb√©m combina _strings_:\n```console.log(\"o\" + \"i\")```\n\nD√™ uma olhada no c√≥digo a seguir:\n```*let frase = \"Ol√°,\"\nfrase = frase + \"Mundo\"\nfrase + \"!\"\nconsole.log(frase)```\nO que vai aparecer no console quando for executado?\n|`\"Ol√°, Mundo!\"`|`\"Ol√°,Mundo!\"`|`\"Ol√°, Mundo\"`|*`\"Ol√°,Mundo\"`|Espa√ßos **n√£o** s√£o inseridos automaticamente entre palavras. A terceira linha de c√≥digo n√£o faz nada pois √© preciso um sinal de igual para alterar a vari√°vel."
			}
		]
	},
	{
		"pathDirectory": "listas",
		"title": "Listas",
		"pages": [
			{
				"path": "criando-uma-lista",
				"subtitle": "Criando uma lista",
				"content": "Listas s√£o uma maneira de agregar informa√ß√µes. Uma lista tamb√©m pode ser chamada de \"vetor\", ou por seu nome em ingl√™s, _\"Array\"_. Uma lista √© criada com [colchetes] e v√≠rgulas:\n```let minhaListaDeCompras = [\"p√£o\", \"leite\", \"arroz\", \"50 litros de √°cido sulf√∫rico\", \"queijo\"]```\nUma lista pode conter qualquer coisa que uma vari√°vel pode.\n```let numeros = [0, 1, 2, 3, 4, 5]\n// e pode misturar coisas, mas isso n√£o √© t√£o comum\nlet listaMisturada = [6.5, \"alface\", -10]```\nPode conter a mesma coisa mais de uma vez:\n```let listaDeComprasMelhor = [\"p√£o\", \"leite\", \"arroz\", \"leite\", \"queijo\", \"leite\", \"leite\"]```\nPode ainda n√£o conter nada:\n```let politicosHonestos = []```\nPara saber quantas coisas est√£o numa lista usamos `.length`:\n```let lista = [55, 44, 33, 22, 11]\nconsole.log(lista.length)```\nA palavra _**length**_ √© ingl√™s para comprimento. Ela tamb√©m funciona para descobrir o tamanho de uma _string_.\n```console.log(\"abcdefghijklmnopqrstuvwxyz\".length)```\n```console.log(\"\".length)```\nDo mesmo jeito que listas podem ser vazias, `\"\"` √© uma string vazia.\nListas e strings vazias t√™m um comprimento/tamanho de 0."
			},
			{
				"path": "acesso",
				"subtitle": "Acesso",
				"content": "Para acessar itens individuais de uma lista voc√™ usa os colchetes de novo, e coloca dentro a posi√ß√£o.\nCada posi√ß√£o √© um n√∫mero diferente, **come√ßando do 0**! O n√∫mero da posi√ß√£o √© chamado de **√≠ndice**.\n```let numeros = [2, 4, 8, 16]\nconsole.log(numeros[0])\nconsole.log(numeros[2])```\nO mesmo truque funciona para extrair caracterers individuais de uma string.\nEspa√ßos s√£o caracteres tamb√©m. Novamente a primeira letra fica na posi√ß√£o 0.\n```let frase = \"Calma, tudo passa. Nem que seja por cima de voc√™.\"\nconsole.log(frase[$NUMBER])```\nEnquanto escolhia um n√∫mero, voc√™ pode ter se deparado com o resultado `undefined`.\nEle significa **\"indefinido\"**, e aparece se escolher um n√∫mero muito grande, ou um n√∫mero negativo, ou um n√∫mero n√£o inteiro, pois esses n√∫meros n√£o s√£o posi√ß√µes v√°lidas.\nLembrando que onde encaixa um n√∫mero encaixa uma vari√°vel de n√∫mero:\n```let lista = [1, 2, 4, 8, 16, 32, 64]\nlet indice = 1\nconsole.log(lista[indice])\nconsole.log(lista[2 + 2]) // e uma opera√ß√£o tamb√©m```\n\nQual o resultado do c√≥digo abaixo?\n```*let string = \"98765-4321\"\nconsole.log(string[string.length - 1])```\n|`undefined`|*`\"1\"`|`\"2\"`|`\"9\"`|O tamanho da string √© 10, ent√£o o resultado √© o mesmo que `string[10 - 1]`. Come√ßando do 0, o caractere na posi√ß√£o 9 √© o √∫ltimo. As aspas ainda aparecem porque o 1 √© parte de uma string, ent√£o tem a fun√ß√£o de caractere."
			},
			{
				"path": "at",
				"subtitle": ".at( )",
				"content": "O c√≥digo anterior sempre resulta no √∫ltimo caractere de uma string, ou no √∫ltimo item de uma lista.\n```let string = $TEXT\nconsole.log(string[string.length - 1])```\n√â comum fazer este tipo de coisa, mas existe um jeito mais simples:\n```let ultimo = [4, 0, 0, 2, 8, 9, 2, 2].at(-1)\nconsole.log(ultimo)```\n`.at()` acessa elementos da lista assim como o `[]`.\nFuncionam iguais com n√∫meros positivos, mas al√©m disso, `.at()` permite usar n√∫meros negativos para buscar itens no final: -1 √© o √∫ltimo item, -2 √© o pen√∫ltimo, -3 √© o antepen√∫ltimo...\n```let frase = \"Calma, tudo passa. Nem que seja por cima de voc√™.\"\nconsole.log(frase.at($NUMBER))```"
			},
			{
				"path": "modificando",
				"subtitle": "Modificando",
				"content": "Para alterar listas depois que elas forem criadas, temos uma variedade de op√ß√µes.\nPrimeiramente, al√©m de acessar, colchetes s√£o usados para substituir itens em listas.\n```let lista = [\"a\", \"b\", \"c\", \"d\"]\nlista[0] = \"e\"\nconsole.log(lista)```\nListas podem ser aumentadas com as opera√ß√µes `.push()` e `.unshift()`:\n```let lista = [2, 4, 8, 16, 32]\nlista.push(16 * 2) // adiciona ao final\nlista.unshift(1) // adiciona ao come√ßo\nconsole.log(lista)```\nDessa vez o s√≠mbolo de igual n√£o √© usado.\nTamb√©m √© poss√≠vel adicionar mais de um item por vez com essas opera√ß√µes:\n```let animais = [\"bicho-pregui√ßa\"]\nanimais.push(\"diabo da tasm√¢nia\", \"axolote\")\nanimais.unshift(\"ornitorrinco\", \"peixe-bolha\", \"capivara\")\nconsole.log(animais)```\nPara remover itens de uma listam, existem `.pop()` e `.shift()`.\nO item removido acaba sendo o resultado, isso quer dizer que a opera√ß√£o pode ser usada no lugar de outros valores:\n```let lista = [1, 1, 2, 3, 5, 8, 13]\nlet ultimo = lista.pop() // remove do final\nlet primeiro = lista.shift() // remove do come√ßo\nconsole.log(lista)\nconsole.log(ultimo)\nconsole.log(primeiro)```"
			}
		]
	},
	{
		"pathDirectory": "tipos-e-conversoes",
		"title": "Tipos e convers√µes",
		"pages": [
			{
				"path": "condicoes",
				"subtitle": "Condi√ß√µes",
				"content": "Por enquanto todo o c√≥digo aqui foi executado, mas frequentemente, voc√™ precisa que um peda√ßo do c√≥digo s√≥ aconte√ßa √†s vezes.\nIntroduzindo, `if`:\n```if (10 > 5) {\n\tconsole.log(\"Executei!\")\n}```\n```if (10 < 5) {\n\tconsole.log(\"Executei!\")\n}```\nO segundo n√£o era para fazer nada mesmo. A palavra `if` significa \"se\", em ingl√™s, e usando ela podemos definir c√≥digo que s√≥ √© executado √†s vezes.\nO primeiro bloco executa porque `10 > 5` √© verdadeiro. O s√≠mbolo `>` √© chamado de \"maior do que\".\nO resultado dele √© verdadeiro **se** o primeiro n√∫mero √© **maior do que** o segundo.\n```console.log(10 > 5) // true significa verdadeiro\nconsole.log(0 > 1) // false significa falso```\nO s√≠mbolo `<` √© o oposto, ele se chama \"menor do que\".\n```console.log(10 < 5) // 10 n√£o √© menor do que 5\nconsole.log(0 < 1) // 0 √© menor do que 1```\nPara checar se os n√∫meros s√£o iguais, usa-se o s√≠mbolo `===`. Cuide para n√£o confundir com o `=` que s√≥ define vari√°veis.\nJ√° o s√≠mbolo `!==` √© o oposto, checa se os n√∫meros s√£o diferentes.\n```console.log(3 === 3)\nconsole.log(3 !== 3)```\nH√° varia√ß√µes dos s√≠mbolos `>` e `<` que tamb√©m permitem que os n√∫meros sejam iguais:\n```console.log(6 >= 4) // maior ou igual\nconsole.log(4 >= 4)```\n```console.log(-5 <= -5) // menor ou igual\nconsole.log(3 <= -5)```\n`===` e `!==` tamb√©m funcionam com strings:\n```console.log(\"biscoito\" === \"bolacha\")\nconsole.log(\"üç™\" === \"üç™\")```\nO `if` usa {chaves} para definir um **bloco de c√≥digo**.\nO espa√ßo em branco no come√ßo das linhas deixa mais f√°cil de ver que parte do c√≥digo est√° dentro do bloco.\n```let numero = $NUMBER\nif (numero >= 0) {\n\tconsole.log(\"positivo ou zero\")\n} else {\n\tconsole.log(\"negativo\")\n}```\nJ√° esse `else` √© uma adi√ß√£o opcional. O bloco de c√≥digo dele executa quando o `if` falhar. Volte aos primeiros exemplos da p√°gina pra garantir que entendeu o que aconteceu.\nE finalmente, `true` e `false` podem ser usados como valores de vari√°vel:\n```const verdadeiro = true\nif (verdadeiro) {\n\tconsole.log(\"sim\")\n}```"
			},
			{
				"path": "numeros-e-strings",
				"subtitle": "N√∫meros e strings",
				"content": "Todo valor possui um tipo associado a ele. Voc√™ j√° viu n√∫meros, strings, listas.\nH√° uma distin√ß√£o importante entre n√∫meros e strings.\n```const um = 1 // n√∫mero\nconst uno = \"1\" // string```\nAnteriormente, houve um caso em que acessar um caractere de uma string resultou em um n√∫mero armazenado como string.\nEsse exemplo √© parecido, o `\"1\"` √© uma string por causa das aspas.\nOs dois valores acima n√£o s√£o id√™nticos.\n```console.log(1 === \"1\")```\nTentar fazer somas usando strings assim causa problemas:\n```console.log(\"4\" + 2 + 0)```\nEm vez de somar os n√∫meros, a funcionalidade de juntar strings do `+` que ocorreu.\nNesse processo, o `2` e o `0` foram convertidos em strings implicitamente. Para consertar isso, convertemos o `\"4\"` para n√∫mero assim:\n```console.log(Number(\"4\") + 2 + 0)```\nDe forma mais geral, `Number()` converte para n√∫mero, `String()` para string.\n```console.log(String(13))\nconsole.log(String(true))\nconsole.log(String(\"Chinforinfola\"))\nconsole.log(Number(\"-1.50\"))```\n```console.log(Number($TEXT))```\nTentou colocar algo que n√£o seja um n√∫mero no campo de texto? **‚¨Ü**\nO resultado acaba sendo um tal de `NaN`.\n`NaN` √© um acr√¥nimo para _\"Not a Number\"_, que significa \"n√£o √© um n√∫mero\", em ingl√™s. At√© porque \"abacaxi\" n√£o √© um n√∫mero.\n```console.log(Number(\"1Ô∏è‚É£\")) // 1Ô∏è‚É£ tamb√©m n√£o √© n√∫mero\nconsole.log(Number(\"\")) // Mas aparentemente nada √©```\nOutro jeito de converter de n√∫mero para string √© usando `.toFixed()`:\n```let numero = 6.54321\nconsole.log(numero.toFixed(3))```\nEssa √© outra daquelas fun√ß√µes que v√£o atr√°s do valor.\nO n√∫mero dentro dos par√™nteses define quantas casas aparecem depois da v√≠rgula. Colocar um `0` a√≠ arredonda o n√∫mero para inteiro.\n```let inteiro = (9.4).toFixed(0)\n// √© neces√°rio () em volta do n√∫mero para usar .toFixed() diretamente\nconsole.log(inteiro)```\nArredondamento para cima tamb√©m acontece.\n```console.log((9.6).toFixed(0))\nconsole.log((6.66666).toFixed(4))```\nE preenche com 0 para ficar do tamanho correto.\n```let reais = $NUMBER\nconsole.log(\"R$\" + reais.toFixed(2))```"
			},
			{
				"path": "mais-tipos",
				"subtitle": "Mais tipos",
				"content": "Para descobrir o tipo de um valor usa-se o `typeof`.\n```console.log(typeof \"3.14\")\nconsole.log(typeof Number(\"3.14\"))```\nAl√©m de n√∫meros e strings, voc√™ viu tamb√©m verdadeiro e falso, esses s√£o do tipo _boolean_.\n```console.log(typeof true)\nconsole.log(typeof false)```\nListas resultam no tipo de _objeto_.\n```console.log(typeof [])```\nO tipo de objeto √© algo mais abrangente do que s√≥ lista. Mesmo asism, falar que s√£o listas ainda √© mais espec√≠fico e adequado. O nome real do tipo lista √© _Array_, como mencionado antes.\nJ√° `undefined` √© o seu pr√≥prio tipo:\n```console.log(typeof undefined)```\nE apesar de `NaN` n√£o ser um n√∫mero, ele √© um n√∫mero:\n```console.log(typeof NaN)```\nüôÉ"
			},
			{
				"path": "convertendo-listas",
				"subtitle": "Convertendo listas",
				"content": "###De lista para string\nO jeito principal de converter uma lista para uma string √© usando `.join()`.\n```console.log([4, 8, 15, 16, 23, 42].join())```\nEle junta os itens da lista e usa v√≠rgulas para separar eles. No lugar das v√≠rgulas, um separador pode ser definido.\n```console.log([1, \"1\", 1, \"1\"].join(\"/\"))\nconsole.log([2, 3, 5, 7, 11].join(\" - \"))```\nUma string vazia `\"\"` efetivamente junta sem um separador.\n```console.log([\":\", \"\", \"/\"].join(\"\"))```\nA fun√ß√£o `String()` pode ser usada aqui tamb√©m. Ela separa os itens por v√≠rgulas, o mesmo que a vers√£o vazia do `.join()`.\n```console.log(String([\"üêç\", \"üö¨\"]))```\n###De string para lista\nPara criar uma lista a partir de uma string, usa-se `.split()`.\n```let string = \"Defenestrar-te-ei!\"\nconsole.log(string.split(\"-\"))```\n√â o oposto do `.join()`: divide a string toda vez que encontrar o separador determinado entre os par√™nteses.\n```console.log(\"->1->2->3->4\".split(\"->\"))```\nNo pr√≥ximo exemplo, `\" \"` √© uma string que cont√©m apenas um espa√ßo.\n```console.log(\"Achei que fosse imposs√≠vel, mas quando fui tentar, descobri que era mesmo.\".split(\" \"))```\nUma string vazia como separador divide em caracteres individuais.\n```console.log($TEXT.split(\"\"))```"
			}
		]
	},
	{
		"pathDirectory": "repeticoes",
		"title": "Repeti√ß√µes",
		"pages": [
			{
				"path": "de-novo",
				"subtitle": "De novo!",
				"content": "Digamos que voc√™ tem uma lista de pre√ßos e quer descobrir o total dela. Como faria?\n```let precos = [24.99, 9.99, 11.99, 69.90]```\nTalvez assim:\n```let precos = [24.99, 9.99, 11.99, 69.90]\nconsole.log(precos[0] + precos[1] + precos[2] + precos[3])```\nFuncionou. Mas o que acontece se vc decidir que quer comprar mais alguma coisa?\n```let precos = [24.99, 9.99, 11.99, 69.90]\nprecos.push(8.50)\nconsole.log(precos)\nconsole.log(precos[0] + precos[1] + precos[2] + precos[3])```\nAgora tem uma coisa a mais na lista, mas o resultado foi o mesmo. :(\n√â claro que d√° para adaptar o c√≥digo:\n```let precos = [24.99, 9.99, 11.99, 69.90]\nprecos.push(8.50)\nconsole.log(precos[0] + precos[1] + precos[2] + precos[3] + precos[4])```\nPor√©m seria mais conveniente se existisse um peda√ßo de c√≥digo que funcionasse sempre.\n```let precos = [24.99, 9.99, 11.99, 69.90, 8.50]\nlet total = 0\nfor (const valor of precos) {\n\ttotal = total + valor\n}\nconsole.log(total)```\nOlha s√≥, tem mesmo! At√© parece que eu sabia que ele existia esse tempo todo.\nEu sei, tem muita coisa acontecendo a√≠. A parte essencial √© essa:\n```*for (const valor of precos) {\n\n}```\n`for` e `of` s√£o mais 2 palavras especiais.\nUsando esse c√≥digo, qualquer instru√ß√£o entre as {chaves} (ou seja, no bloco de c√≥digo) √© repetida uma vez por item na lista.\n```let letras = [\"a\", \"b\", \"c\"]\nfor (const valor of letras) {\n\t// 3 vezes\n\tconsole.log(\"De novo!\")\n}```\nEsse `const valor` √© algo que voc√™ j√° viu: esse c√≥digo cria uma vari√°vel chamada valor.\nCada vez que o c√≥digo interior executa, a vari√°vel criada cont√©m um item da lista, em ordem. Voc√™ pode escolher o nome dela.\n```let sequencia = [0, 1, 2, 3]\nfor (const numero of sequencia) {\n\tconsole.log(numero)\n}```\nVoc√™ tamb√©m j√° viu que `total = total + valor` soma o valor √† vari√°vel total. Como esse peda√ßo do c√≥digo est√° entre as chaves, ele executa com a lista toda, somando toda a lista no total.\n\nVeja uma vers√£o um pouco diferente que mostra o total sendo calculado:\n```let precos = [24.99, 9.99, 11.99, 69.90, 8.50]\nlet total = 0\nfor (const valor of precos) {\n\ttotal = total + valor\n\tconsole.log(total)\n}```\nE ent√£o, qual valor esse c√≥digo mostra na tela?\n```*let resultado = 100\nfor (const v of [40, 10, 10]) {\n\tresultado = resultado - v\n}\nconsole.log(resultado)```\n|20|30|*40|60|O resultado come√ßa em 100 e √© subtra√≠do por cada item na lista, ou seja, `100 - 40 - 10 - 10`."
			},
			{
				"path": "de-novo-de-novo",
				"subtitle": "De novo! (de novo)",
				"content": "√Äs vezes voc√™ quer fazer um peda√ßo do c√≥digo eexecutar m√∫ltiplas vezes, mas sem nenhuma associa√ß√£o √† uma lista.\nUm jeito de fazer isso √© usando a palavra-chave `while`.\n```let string = $TEXT\nwhile (string.length < 20) {\n\tstring = string + \"-\"\n}\nconsole.log(string)```\n√â parecido com o `if` no sentido que o bloco de c√≥digo √© executado quando a condi√ß√£o for verdadeira. Mas dessa vez, ele continua sendo executado at√© que a condi√ß√£o n√£o seja mais verdadeira. No caso anterior, h√≠fens foram adicionados ao final da string at√© que ela chegasse √† 20 caracteres.\nCada execu√ß√£o do bloco de c√≥digo interno √© chamada de uma **itera√ß√£o**.\nA condi√ß√£o √© checada no come√ßo de cada itera√ß√£o, incluindo a primeira:\n```while (1 > 2) {\n\tconsole.log(\"Nunca executa\")\n}```\nS√≥ cuide para n√£o criar um loop infinito. Esse c√≥digo abaixo vai fazer o que estiver executando ele travar:\n```*while (true) {\n\tconsole.log(\"Eu sou eterno. Quando eu come√ßar, corra, porque eu n√£o paro mais.\")\n}```\nTanto o `for of` quanto o `while` s√£o chamados de **estruturas de repeti√ß√£o**.\nExiste mais uma delas..."
			},
			{
				"path": "mais-uma-vez",
				"subtitle": "E mais uma vez",
				"content": "```let repeticoes = 5\nfor (let i = 0; i < repeticoes; i++) {\n\tconsole.log(i)\n}```\nEssa estrutura de repeti√ß√£o √© chamada s√≥ de `for`.\n`let i = 0` √© executado uma vez antes de todo o resto, ciando a vari√°vel `i` que come√ßa em 0. O nome de vari√°vel `i` √© bem comum nesse cen√°rio mas tamb√©m pode ser alterado.\n`i++` √© a mesma coisa do que `i = i + 1`, acontece no final de cada itera√ß√£o. O resultado √© que `i` vai subindo de 1 em 1.\n`i < repeti√ß√µes` funciona exatamente como no `while`: A condi√ß√£o √© checada no come√ßo de cada itera√ß√£o e quando for falsa, o c√≥digo vai parar de reexecutar. Nesse caso parou logo quando `i` chegou a 5, pois `5 < 5` √© falso, de forma que `i` nunca teve o valor 5 dentro do bloco de c√≥digo.\nO `while` consegue fazer as mesmas coisas do que o `for`, por√©m o c√≥digo fica mais diseperso. E como o `while` √© mais gen√©rico, usar `for` transmite melhor o seu objetivo. Este aqui √© equivalente ao do come√ßo da p√°gina:\n```let repeticoes = 5\nlet i = 0\nwhile(i < repeticoes) {\n\tconsole.log(i)\n\ti++\n}```\nEm rela√ß√£o ao `for of`, o `for` √© mais dif√≠cil de usar, mas oferece mais liberdade. Permite modificar o valor inicial:\n```for (let i = 6; i < 9; i++) {\n\tconsole.log(i)\n}```\nAinda pode ser usada com uma lista:\n```let emojis = [\"üòê\", \"ü•∂\", \"üò°\", \"üò±\"]\nfor (let indice = 0; indice < emojis.length; indice++) {\n\tconsole.log(emojis[indice])\n}```\nE diferente de um `for of`, pode alterar uma lista:\n```let documentos = [\"RG\", \"CNH\", \"Passaporte\"]\nfor (let i = 0; i < documentos.length; i++) {\n\tdocumentos[i] = false\n}\nconsole.log(documentos)```"
			}
		]
	}
]
